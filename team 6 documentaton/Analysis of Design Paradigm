Team Four used an object-oriented design paradigm with an emphasis on classes to represent the various game elements. However, one could also say they used some aspects of the event-driven programming paradigm as well. This is reflected in the architecture of the pygame library, which is powered by a loop that runs while the game is happening. Pygame receives events such as mouse moves and clicks. Then, the code reacts to those events as they occur in an object-oriented fashion.

To be more specific, the main game loop in main.py watches for two events: QUIT and MOUSEBUTTONDOWN. These events represent the acts of the window being exited and the mouse button being clicked, respectively. The former’s consequences are obvious. The latter represents the main entry point into the program’s object-oriented functionality.

When the mouse button is clicked, the code retrieves the position of the mouse using pygame’s built-in function. Then, the game’s select function is called. This function represents selecting a square. Once a square is selected, the various game elements react: the board updates its hitmarkers and ship representations and checks if the power-up was hit. It also checks if the game ends; if so, the main game loop ends.

This birds-eye view of the architecture implemented by Team 4 should make it clear the program has both event-driven and object-oriented aspects. On one hand, the pygame library lends an event-driven nature to the code given it is built to respond to user input. On the other, a complex system of classes correspond to game objects and manage their own states.
